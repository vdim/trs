\documentclass[a4paper,12pt]{article}

\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[russian]{babel}
\usepackage[unicode,pdfborder={0 0 0},colorlinks=true,urlcolor=blue]{hyperref}
%\usepackage{hyperref}
%\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[top=25mm, left=25mm, right=25mm, bottom=25mm, nohead]{geometry}
\usepackage{indentfirst}
\usepackage{cmlgc}


% Style for showing a name of function or a name of library and so on in the text.
\newcommand{\cl}[1] {{\it #1}}


\title{Монады в Clojure
\footnote{<<Monads in Clojure>>: \href{http://intensivesystems.net/tutorials/monads_101.html}
{http://intensivesystems.net/tutorials/monads\_101.html}.}\\ \vspace{1.0cm} Jim Duey}

\begin{document}

\maketitle

Clojure --- многообещающий и перспективный язык программирования, работающий на платформе JVM 
%Он реализует функциональную парадигму программирования, используя Lisp синтаксис. 
%Он является функциональным языком программирования с Lisp-подобным синтаксисом. 
и являющийся функциональным языком с Lisp-подобным синтаксисом. 

Одной из примечательных идей функционального программирования (ФП) является идея монад. 
Однако, практически все руководства по монадам в сети (а их там множество) используют
язык Haskell. Кроме того, во многих из них к монадам подходят со стороны
теории категорий, поэтому может показаться, что понять монады возможно только обладая
глубокими знаниями в теории ФП. В данной статье я постараюсь развеять эти опасения и
показать как понимать и использовать монады в Clojure.

Konrad Hinsen написал великолепную реализацию монад на Clojure, и я не собираюсь делать
этого заново. Она включена в пакет \cl{clojure.contrib}, поэтому необходимо установить его
в том случае, если у Вас возникнет желание использовать код, который будет приводиться далее. 
Весь код, используемый в статье, доступен \href{http://intensivesystems.net/tutorials/code/monads\_101.clj}
{здесь}.

Konrad также написал статью по монадам в Clojure, которая доступна 
\href{http://onclojure.com/2009/03/05/a-monad-tutorial-for-clojure-programmers-part-1/}{здесь}.



%\section{Первый взгляд}\label{first-looks}
\section{Введение}\label{first-looks}
Монада --- это не более, чем способ композиции функций. 
%которую можно рассмотреть на примере comp из clojure.core:
%Можно рассмотреть композицию функций с помощью comp из clojure.core
Рассмотрим композицию функций с помощью \cl{comp} из \cl{clojure.core}:

\begin{verbatim}
; f1, f2 и f3 представляют собой функции, каждая из которых  
; принимает один аргумент и возвращает некоторый результат.
(comp f1 f2 f3)
\end{verbatim}
\cl{comp} возвращает функцию, в которой результат работы функции \cl{f3} передается функции \cl{f2}
в качестве аргумента, затем возвращаемое значение \cl{f2} передается в \cl{f1}, результат которой, наконец,
%в качестве аргумента, затем результат работы f2 передается в f1, результат которой, наконец,
возвращается пользователю. Следующий код эквивалентен ранее приведенному вызову \cl{comp}:

\begin{verbatim}
(fn [x]
   (f1
     (f2
       (f3 x))))
\end{verbatim}

А что если результат \cl{f3} не соответствует аргументу, который требуется для \cl{f2}? В этом случае,
чтобы использовать их вместе, необходим некий дополнительный код. Пусть все функции \cl{f1}, \cl{f2} и \cl{f3} 
принимают в качестве аргумента целое число, а возвращают список целых чисел. Чтобы получить результат
композиции этих трех функций мы должны написать что-нибудь такое: 

\begin{verbatim}
(fn [x]
   (mapcat f1
           (mapcat f2
                  (f3 x))))
\end{verbatim}

Итак, \cl{f3} получает в качестве аргумента \cl{x} и возвращает список целых чисел. Затем внутренний
\cl{mapcat} применяет \cl{f2} к каждому элементу из этого списка. Каждый вызов \cl{f2} возвращает список целых
чисел. Все эти списки от \cl{f2 mapcat} преобразовывает в единый список целых чисел. Затем внешний
\cl{mapcat} применяет \cl{f1} к каждому целому числу из списка, полученного от внутреннего \cl{mapcat}, и
соединяет результат работы \cl{f1} в один единый список, который и является результатом работы
вышеприведенной функции. Идея, которая стоит за монадами, заключается в том, чтобы избавиться
от этого дополнительного кода, скрыв таким образом сложность функции и оставив на поверхности только 
композицию функций.


%\section{Как работают монады}\label{monad-mechanics}
\section{Внутреннее устройство монады}\label{monad-mechanics}
А как абстрагировать этот дополнительный код? Для начала разберемся с терминологией. 
В статически типизированных языках (как Haskell) функция должна иметь сигнатуру, которая описывает
тип каждого параметра и тип возвращаемого значения. Эта сигнатура может быть сама определена как тип,
поэтому все функции, которые обладают одной и той же сигнатурой, имеют один и тот же тип. Clojure представляет
собой динамически типизированный язык, поэтому функции не имеют сигнатур. Но мы можем сказать, что 
некоторые функции ожидают на вход вполне конкретные типы параметров и возвращают вполне конкретный
тип результата. Мы это проделывали выше, говоря о том, что \cl{f1}, \cl{f2} и \cl{f3} ожидают на вход целое число,
а возвращают список целых чисел. Функции, для которых необходимо провести композицию с помощью монады,
должны иметь один и тот же тип сигнатуры и называются <<монадическими функциями>>. Значения, которые они
возвращают, называются <<монадическими значениями>> и содержат или обертывают базисные значения. 
В выше приведенном примере монадическими значениями являются списки целых чисел (возвращаемые значения
функции), а базисными значениями --- целые числа (аргументы функции).
Любая монадическая функция принимает базисное значение в качестве параметра. %, не монадическое значение.
Если функции принимают монадические значения, получить их композицию можно просто воспользовавшись \cl{comp}.

Теперь можно увидеть, что монадическая функция может быть вызвана обычным образом:

\begin{verbatim}
(f2 4)
\end{verbatim}

А как передать монадической функции монадическое значение? Для этого необходима другая функция, которая
принимает монадическое значение и монадическую функцию в качестве параметров и <<выполняет все, что нужно>>. 
В нашем примере, такой функцией является \cl{mapcat}. Однако, по соглашениям и для того чтобы облегчить
чтение кода, монадическое значение должно стоять перед монадической функцией в вызове функции. Поэтому,
имея монадическое значение \verb|[1 5 7]|, вместо 

\begin{verbatim}
(mapcat f2 [1 5 7])
\end{verbatim}
мы пишем
\begin{verbatim}
(m-bind [1 5 7] f2)
\end{verbatim}

Стоит обратить внимание на две вещи. Во-первых, мы используем вектор в квадратных скобках вместо
списка в круглых. Это идеологически более правильно для Clojure, а также проще читать, так как в круглые
скобки заключается также вызов функции. Во-вторых, что такое \cl{m-bind}?

\cl{m-bind} --- это стандартное имя для функции, которая применяет монадическую функции к монадическому значению. 
Необходимо, чтобы все монады имели функцию с таким именем. В нашем случае \cl{m-bind} будет выглядеть следующим
образом:

\begin{verbatim}
(defn m-bind [mv mf]
      (mapcat mf mv))
\end{verbatim}

Возникает другой вопрос, что если мы хотим применить монадическую функцию к базисному значению? Если 
бы мы смогли преобразовать наше базисное значение в монадическое, мы далее просто могли бы использовать 
функцию \cl{m-bind}. Каждая монада должна иметь такую функции и называться она должна \cl{m-result}. В нашем
примере мы должны написать следующий код 

\begin{verbatim}
(m-result 6)
\end{verbatim}
, который возвратит значение [6]. Поэтому \cl{m-result} должна быть определена следующим образом:

\begin{verbatim}
(defn m-result [x]
      [x])
\end{verbatim}

Итак, первый шаг к пониманию монад сделан. Монада --- это способ композиции (здесь должны возникать понятия сигнатуры
монадической функции, функции с именем \cl{m-result}, преобразующей простое значение в монадическое, и функции с
именем \cl{m-bind}, применяющей монадическую функцию к монадическому значению). Монада может быть использована
для композиции монадических функций, получая таким образом новые монадические функции. 


\section{Композиция}\label{composing}
Как нам теперь создать функцию, являющуюся композицией функций \cl{f1}, \cl{f2} и \cl{f3}, используя
монаду? Можно так:

\begin{verbatim}
(defn m-comp [f1 f2 f3]
      (fn [x]
          (m-bind
              (m-bind
                  (m-bind
                      (m-result x)
                      f3)
                   f2)
               f1)))
\end{verbatim}

На первый взгляд выглядит ужасно. Однако, стоит заметить, что эта функция независима от
используемой монады. Поэтому мы можем использовать ее с любой монадой для композиции 
монадических функций, которые имеют такую же сигнатуру как монада, разработанная нами выше. 
%Также как и \cl{comp}, она может быть использована для композиции обычных функций:
\cl{m-comp}, также как и \cl{comp}, вызывается с функциями в качестве параметра:

\begin{verbatim}
(m-comp f1 f2 f3)
\end{verbatim}

%Все еще выглядит ужасно.


\section{Нотация Do}\label{do-notation}
Более подходящим способом для композиции функций является использование нотации \cl{'do'}. 
Монада, которую мы определили выше, имеется в библиотеке \cl{monads} и %clojure.contrib.monads и 
называется \cl{'sequence-m'}. Монадическим значением для \cl{sequence-m} является последовательность
значений, а параметром монадической функции --- некоторое базисное значение. % и возвращает последовательность значений. 
Стоит заметить, что монадические значения не ограничены последовательностью 
целых чисел, это может быть последовательность значений любых типов. 
Композиция трех функций с использованием нотации \cl{'do'} выглядит следующим образом:

\begin{verbatim}
(defn m-comp [f1 f2 f3]
      (fn [x]
          (domonad sequence-m
                   [a (f3 x)
                    b (f2 a)
                    c (f1 b)]
                   c)))
\end{verbatim}
Этот код выглядит уже менее ужасно, чем код из предыдущей попытки. Конструкция \cl{'domonad'} имеет три части.
Первая часть представляет собой имя монады. Вторая --- это вектор, заключенный
в квадратные скобки и содержащий пары <<имя выражения/выражение>>.
%<<имя переменной
%\footnote{В данном случае термин <<переменная>> отличается от общепринятого определения
%в императивных языках. На самом деле здесь переменная - не переменная, я имя, связанное со
%значением }/выражение>>. 
И наконец, третья часть --- это выражение для возвращаемого значения. 

Здесь и происходит весь фокус. В парах <<имя выражения/выражение>> каждое выражение при выполнении 
возвращает монадическое значение. Т.е. выражение \cl{'(f3 x)'} возвращает монадическое значение, зависящее от
\cl{x}. Однако, монадическое значение не связывается с \cl{'a'}. Вместо этого, \cl{'a'} используется в последующем выражении 
для доступа к базисным значениям, содержащимся внутри монадического значения, которое возвращает \cl{'(f3 x)'}.

Итак, в вышеприведенном примере \cl{'(f3 x)'} возвращает монадическое значение, основанное на \cl{x}, а именно
список значений. Затем \cl{f2} применяется к каждому из значений из этого списка по порядку, производя при 
каждом вызове новый список, который собирается в единый список,
%а результат собирается в один список, 
элементы которого доступны через \cl{'b'}. А затем этот процесс повторяется с \cl{f1}, 
результат которого доступен через \cl{'c'}. 

Последний элемент в \cl{'domonad'} представляет собой выражение для возвращаемого значения. Это
выражение может включать любое имя из второй части \cl{'domonad'} и используется для
получения монадического значения, которое возвращается конструкцией \cl{'domonad'}. Здесь нужно увидеть
важную вещь: результатом \cl{domonad} является монадическое значение, которое создает функция (монадическая), возвращаемая
\cl{m-comp}. Поэтому в дальнейшем \cl{m-comp} может участвовать в композиции с 
другими монадическими функциями, таким образом образуя при помощи композиции дополнительные монадические функции. 
%Композиция является первой составляющей мощи монад. Мы рассмотрим это внимательнее чуть позже.
Композиция является одной из важной составляющей возможностей монад.


%\section{Понимание}\label{comp-on}
%\section{Работа со списками}\label{comp-on}
\section{Раскрытие списков}\label{comp-on}
В предыдущем разделе мы увидели важную вещь: выражения, связанные с некоторыми именами, возвращают
монадические значения. А что будет, если выражения будут содержать просто списки?

Конструкция 

\begin{verbatim}
(domonad sequence-m
         [letters ['a 'b 'c]
          numbers [1 2 3]]
         [letters numbers])
\end{verbatim}
возвращает следующий результат
\begin{verbatim}
([a 1] [a 2] [a 3] [b 1] [b 2] [b 3] [c 1] [c 2] [c 3])
\end{verbatim}

В выражениях не использовались монадические функции, но каждый элемент вектора \cl{letters} образует
пару с каждым элементов вектора \cl{numbers}. Давайте взглянем на другое выражение Clojure, а именно макрос
раскрытия списков (list comprehen- sion):

\begin{verbatim}
(for
   [letters ['a 'b 'c]
    numbers [1 2 3]]
   [letters numbers])
\end{verbatim}
, который возвращает следующий результат:
\begin{verbatim}
([a 1] [a 2] [a 3] [b 1] [b 2] [b 3] [c 1] [c 2] [c 3])
\end{verbatim}

Этот результат показывает другой аспект монад, а именно то, что раскрытие списков
является частным случаем конструкции \cl{domonad} с \cl{sequence-m} монадой. Или, если подойти
с другой стороны, \cl{sequence-m} монада является обобщением раскрытия списков и может иногда
называться монадой раскрытия. Мы рассмотрим ее интересное приложении позже.


%\section{Но почему?}\label{but-why}
\section{В чем преимущество?}\label{but-why}
Все это может быть и привлекательно, но в чем преимущество использования
монад в коде? Одна из фундаментальных концепций информатики заключается в том, чтобы
разделить задачу на подзадачи, решить эти подзадачи и затем использовать
полученные решения для решения первоначальной проблемы. Используя монады, можно разбивать и
разбивать проблему на маленькие части, пока каждая такая часть не будет решена с 
помощью монадической функции. Затем можно использовать комбинацию этих монадических
функций, используя монадические комбинаторы, одним из которых является конструкция 
\cl{domonad}, для решения основной задачи. В итоге мы получаем не только решение нашей
основной задачи, но и набор решенных подзадач, который мы можем комбинировать
для решения похожих проблем без написания нового кода. Это чем-то похоже на блоки Lego,
которые могут использоваться для построения все больших и больших конструкций. Возможности
набора монадических функций не возврастают линейно при добавлении новой 
функции. Они возрастают экспоненциально, потому что каждая новая монадическая
функция может участвовать в композиции со всеми другими монадическими функциями. 
Мы рассмотрим конкретный пример этого в скором времени. 


%\section{Больше мощи}\label{more-power}
%\section{Другие возможности}\label{more-power}
%\section{Больше выразительности}\label{more-power}
%\section{Больше возможностей}\label{more-power}
\section{Монада \cl{state-m}}\label{more-power}
Монада \cl{sequence-m} является хорошим введением в использование монад. 
%Она позволяет увидеть как последовательность может содержать значения других типов. 
%Легко увидеть, как последовательность может содержать значения других, отличных от целого, типов.
Существует еще несколько
простых монад, которые за обманчивой простотой прячут в себе большие возможности. Мы 
вернемся к ним позже. А прямо сейчас рассмотрим другую составляющую великолепия монад. % Пристегнитесь.

Одной из наиболее мощных концепций ФП являются функции первого класса: с такими функциями
%то, что функции являются значениями первого класса. 
можно проделывать все те вещи, что проделываются с целыми числами. Можно связать 
функцию с переменной, передать ее как параметр в другую функцию и возвратить ее 
как результат выполнения функции. Ее также можно использовать как монадическое
значение.

%Что?

Функции сами по себе могут быть монадическими значениями, которые отличаются от их монадических
функций. Это означает, что монада может быть определена так, что монадическая функция
возвращает функцию как монадическое значение. Чтобы понять эту концепцию, необходимо
четко представлять себе различие между функцией, которая является монадическим значением,
и функцией, которая является монадической функцией. 

Давайте рассмотрим конкретный пример, а именно монаду \cl{state-m}. Монадическим значением
монады \cl{state-m} является функция, которая принимает значение (состояние state) в качестве
параметра и возвращают список, который содержит возвращаемое значение и новое значение состояния. 
Состояние может быть любым типом: отображением, строкой, целым числом и так далее. Монадическими
функциями монады \cl{state-m} являются функции, которые принимают значение и возвращают монадическое
значение (функцию, которая принимает значение состояния и возвращает список, состоящий из 
возвращаемого значения и нового состояния). 

Вот пример функции, которая является монадическим значением в монаде \cl{state-m}:

\begin{verbatim}
(defn some-fn [state]
     ; do something
     ; and something else
     [return-value new-state])
\end{verbatim}

Заметим, что функция сама по себе является монадическим значением, а не ее значение состояния.

Теперь давайте определим несколько таких функций, в которых состояние будет целым число, а их
работа будет заключаться в простом увеличении этого состояния. Возвращаемым значением (первым элементом
списка) этих функций будут константы.

\begin{verbatim}
(defn g1 [state-int]
      [:g1 (inc state-int)])

(defn g2 [state-int]
      [:g2 (inc state-int)])

(defn g3 [state-int]
      [:g3 (inc state-int)])
\end{verbatim}

Теперь без определения каких-либо еще монадических функций для этой монады давайте произведем
их композицию, используя выражение \cl{domonad}, и привяжем результат \cl{domonad} к некоторому имени. 
Напомню, что \cl{g1}, \cl{g2} и \cl{g3} являются монадическими значениями и поэтому используются прямо в
\cl{domonad}, без всякого вызова для получения значения, которые они возвращают:

\begin{verbatim}
(def gs (domonad state-m
                 [a g1
                  b g2
                  c g3]
                 [a b c]))
\end{verbatim}

Какое значение имеет \cl{'gs'}? Мы знаем, что \cl{domonad} возвращает монадическое значение, а для монады
\cl{state-m} монадическим значением является функция, которая принимает значение состояния. Поэтому
\cl{'gs'} является функцией от одного аргумента, которым является состояние. 

А что эта функция возвращает? Монадическое значение монады \cl{state-m} возвращает список
с возвращаемым значением и новым состоянием, поэтому именно это вернет \cl{'gs'}. Ее возвращаемое
значение (первый элемент списка) определено выражением  \cl{'[a b c]'}, где переменные связаны с возвращаемыми значениями
функций \cl{g1}, \cl{g2} и \cl{g3} соответственно. А что за значение состояния вернет \cl{'gs'}? Может быть это и 
не очевидно, но она вернет значение состояния, полученного от \cl{g3}. 

Поэтому 

\begin{verbatim}
(gs 5)
\end{verbatim}

вернет

\begin{verbatim}
([:g1 :g2 :g3] 8)
\end{verbatim}

Другим интересным моментом монады \cl{state-m} является наличие специальных функций.
Например, функция

\begin{verbatim}
(defn fetch-state []
      (fn [state]
          [state state]))
\end{verbatim}
вернет функцию, которая может быть использована для получения значения состояния
в любой точке выражения \cl{domonad}:

\begin{verbatim}
(def gs1
     (domonad state-m
              [a g1
               x (fetch-state)
               b g2]
              [a x b]))

(gs1 3)
\end{verbatim}
вернет
\begin{verbatim}
([:g1 4 :g2] 5)
\end{verbatim}

Имя выражения \cl{'x'} будет связано со значением состояния, которое было в момент вызова \cl{fetch-state}.

Противоположной для \cl{fetch-state} функцией является \cl{set-state}:

\begin{verbatim}
(defn set-state [new-state]
      (fn [old-state]
          [old-state new-state]))
\end{verbatim}

Код 

\begin{verbatim}
(def gs2
     (domonad state-m
              [a g1
               x (set-state 50)
               b g2]
              [a x b]))

(gs2 3)
\end{verbatim}
вернет

\begin{verbatim}
([:g1 4 :g2] 51)
\end{verbatim}

Заметим, что \cl{fetch-state} и \cl{set-state} не являются монадическими значениями. Они 
представляют собой функции, которые возвращают монадические значения для монады \cl{state-m}, принимая
состояние и возвращая список, состоящий из возвращаемого значения и нового значения состояния. При этом
\cl{set-state} является монадической функцией, так как она принимает аргумент, который является новым состоянием
и возвращает функцию, которая при своем вызове устанавливает состояние в это значение. 

%На самом деле \cl{fetch-state} и \cl{set-state} независимы, однако, так удобнее о них думать.

Если мы заглянем внутрь монады \cl{state-m}, то увидим следующее определение:

\begin{verbatim}
(defn m-result [v]
      (fn [s]
          (list v s)))

(defn m-bind [mv f]
      (fn [s]
          (let [[v ss] (mv s)]
               ((f v) ss))))
\end{verbatim}

Функция \cl{m-result} принимает значение и возвращает функцию, которая принимает состояние и 
возвращает значение и состояние единым списком. Никаких фокусов, так как можно вспомнить, что
\cl{m-result} должна возвращать монадическое значение, которое в данном случае является функцией. 

Функция \cl{m-bind} немного сложнее. Во-первых, заметим, что она, как и положено, принимает два
параметра. Первым аргументом является монадическое значение, которое представляет собой функцию. 
Вторым аргументом является монадическая функция. А сейчас будет интересно: параметр, с которым работает 
эта монадическая функция не является монадическим значением. На самом деле это значение, которое 
возвращается, когда функция применяется к состоянию. 

Итак, \cl{m-bind} возвращает функцию, которая является монадическим значением и принимает в качестве
аргумента значение состояния. Монадическое значение, которым является первый аргумент \cl{m-bind},
применяется к этому значению состояния и возвращает некоторое новое значение и новое состояние. 
(Конструкция \cl{'let'} используется для того, чтобы по отдельности использовать элементы возвращаемого
списка от монадического значения.) Затем монадическая функция применяется к этому некоторому значению, 
возвращая функцию, которая является монадическим значением. Эта последняя функция применяется к
новому состоянию, возвращая, наконец, конечные значение и состояние. 

Все это сбивает с толку. Попытка выполнять примеры в REPL приводит к долгому осознанию того, как это
все работает. Ведь нужно помнить, что для монады \cl{state-m} монадическим значением является функция, которая
принимает значение состояния и возвращает список из возвращаемого значения и нового состояния. Монадическая
функция принимает значение и возвращает монадическое значение, которое является функций и так далее, и так далее.
Но понять монады, стоит потраченных усилий.

Давайте на мгновение вернемся на шаг назад и вспомним, что состояние может быть любым. Например, оно может быть
отображением, в котором значения ассоциированы с ключевыми символами (keyword). А функция, являющаяся
монадическим значением, может изменять значения в этом отображении, имея таким образом глобальное изменяемое
состояние и все еще сохраняя при этом все преимущества программирования без побочных эффектов. 
Также состояние может быть строкой, которая разбирается функцией (организация
синтаксического анализатора), или целым числом, которое увеличивается или уменьшается на единицу (организация счетчика).

Также монада \cl{state-m} может быть использована для организации многоуровневой абстракции в одном приложении.
Для примера давайте рассмотрим хорошо известную игру Pac-Man. На одном уровне состоянием может быть
текущий лабиринт, а монадическими значениями могут быть функции, которые обновляют позиции всех персонажей,
проверяют коллизии, создают видео фреймы или проигрывают звуки. Эти функции могут участвовать в композиции
при помощи \cl{m-bind}, образуя единственную функцию, принимающую текущее состояние лабиринта и возвращающую следующее.

Эта функция может быть использована более высоким уровнем абстракции, где состоянием будет являться
список начальных состояний лабиринтов, по одному для каждого этапа игры. Монадическим значением 
этого уровня абстракции будет функция, позволяющая игроку играть на текущем лабиринте. Как только
игрок проходит лабиринт, снова вызывается эта функция со списком оставшихся лабиринтов. 


\section{Законы}\label{Legalities}
В нашем первом определении монады мы говорили о том, что составляющими любой монады являются
сигнатура функции, функция под названием \cl{m-result} и функция под названием \cl{m-bind}. 
Но мы не упомянули, что \cl{m-result} и \cl{m-bind} не могут быть любыми функциями. Они должны работать
вместе так, чтобы монадическая функция могла свободно участвовать в композиции, возвращая 
предсказуемый результат. Эти правила постулированы в трех законах монад, которые \cl{m-result} и \cl{m-bind}
обязаны соблюдать для того, чтобы получилась монада. Вспомним, что \cl{m-result} преобразует 
базисное значение в монадическое, а \cl{m-bind} применяет монадическую функцию к базисному значению, извлеченному
из монадического значения. 

Первый закон

\begin{verbatim}
(m-bind (m-result x) f) эквивалентно (f x)
\end{verbatim}
означает, что что бы \cl{m-result}  ни делало с \cl{'x'}, превращая его в монадическое значение,
\cl{m-bind} преобразует его обратно, применяя \cl{'f'} к \cl{'x'}.

Второй закон:

\begin{verbatim}
(m-bind mv m-result) эквивалентно mv
\end{verbatim}
, где \cl{'mv'} представляет собой монадическое значение. Этот закон дополняет первый. 
Он гарантирует, что что бы \cl{m-bind} ни делало для извлечения значения из монадического значения, 
монадическая функция \cl{m-result} преобразует это значение обратно в монадическое значение. 

При работе монады \cl{m-result} и \cl{m-bind} являются зависимыми функциями: каждая из них зависит 
от реализации другой, и два вышеприведенных закона четко описывают схему зависимости. 

Третий закон:

\begin{verbatim}
(m-bind (m-bind mv f) g) эквивалентно (m-bind mv (fn [x] (m-bind (f x) g)))
\end{verbatim}
, где \cl{'f'} и \cl{'g'} являются монадическими функциями, а \cl{'mv'} --- монадическим значением.
Третий закон говорит о том, что не важно применяется ли \cl{'f'} к \cl{'mv'}, а затем \cl{'g'} к полученному результату, или
создается новая монадическая функция, являющаяся композицией \cl{'f'} и \cl{'g'}, которая затем применяется к \cl{'mv'}.
В любом случае результатом должно быть одно и то же монадическое значение. 

Один интересный факт возникает из того, что все монады должны следовать этим трем законом: функции, которые
написаны только с помощью \cl{m-result} и \cl{m-bind} будут работать для всех монад. Это повышает уровень абстракции, на котором
строятся программы, скрывая частности, они делают структуру приложения простой и наглядной. 


\section{Нулевой элемент}\label{zeros}
До сих пор мы обсуждали только функции \cl{m-result} и \cl{m-bind}, так как это минимум, который обязана
реализовывать монада, чтобы называться монадой. Если монада определит несколько больше функций,
то это сделает ее более выразительной.

Есть много полезных вещей, которые могут быть выполнены при использовании только натуральных чисел
(1, 2, 3 ...). Однако, когда добавляется концепция <<отсутствия (nothing)>> при помощи цифры 0, то такая система
чисел становится более полезной. Точно таким же образом, когда монада добавляет концепцию <<отсутствия>>, она
становится полезной для решения большего круга проблем.

Стандартным именем для монадического значения <<отсутствия>> является \cl{'m-zero'}, и оно должно соблюдать
несколько законов. Первый закон

\begin{verbatim}
(m-bind m-zero f) возвращает m-zero
\end{verbatim}
говорит о том, что любая попытка применить монадическую функцию к \cl{m-zero} вернет \cl{m-zero}. 

Второй закон

\begin{verbatim}
(m-bind mv (fn [x] m-zero)) возвращает m-zero
\end{verbatim}
гласит, что любая монадическая функция, которая возвращает \cl{m-zero}, всегда будет возвращать
значение \cl{m-zero} независимо от того, к какому монадическому значению она применяется.

\cl{m-zero} может быть полезна для определения ошибки или завершения дальнейшего выполнения \cl{domonad}. 



\section{Операция сложения}\label{plus}
Другим расширением монады, близко связанным с \cl{m-zero}, является операция сложения, которая обычно
определяется функцией с именем \cl{m-plus}.
%Монада может определить функцию с именем m-plus. 
Эта функция принимает два или более монадических значения 
и манипулирует ими определенным способом, образуя новое монадическое значение. Существует 
несколько законов, которые связывают \cl{m-zero} и \cl{m-plus}:

\begin{verbatim}
(m-plus mv m-zero) возвращает mv
(m-plus m-zero mv) возвращает mv
\end{verbatim}

Эти два закона представляют собой два разных способа выразить одно и тоже: \cl{m-plus} игнорирует
любой параметр, имеющий \cl{m-zero} значение, а остальными оперирует обычным образом. 



\section{Синтаксический анализ}\label{parsing}
Предыдущий материал являлся введением в монады. Теперь, очевидно, возникает
вопрос, а для чего монады пригодны? Для того чтобы проиллюстрировать пригодность
монад на примере, рассмотрим синтаксический анализ методом рекурсивного спуска. 

Синтаксический анализ (парсинг) представляет собой извлечение в соответствии с заданной грамматикой 
из последовательности символов смысла. Метод рекурсивного спуска пытается разобрать последовательность
символов, следуя некоторому правилу. Если правило не выполняется, то метод пытается
разобрать ту же последовательность с помощью другого правила. Построение синтаксического анализатора 
(парсера) возможно с помощью монад, и сделать это будет на удивление легко. Монады и другие функции, 
приведенные ниже, представлены в статье \href{http://www.cs.nott.ac.uk/~gmh/pearl.pdf}{<<Monadic Parsing in Haskell>>}. 

Идея состоит в том, чтобы определить парсер как функцию, принимающую строку в качестве параметра и определяющую соответствует ли она
грамматике или нет. Если строка (или некоторая начальная часть строки) удовлетворяет парсеру, то он (в нашем случае это функция) 
возвращает некоторое значение, которое является смыслом
разобранной части, и оставшуюся после разбора часть строки.
%и часть строки, которая осталась после того, как парсер забрал себе столько сколько ему нужно было символов. 
Если строка не удовлетворяет парсеру, возвращается \cl{nil}. Как и все элегантные идеи, эта идея очевидна,
%но была достигнута ценой больших усилий. Статья, описывающая ее, стоит того, чтобы ее прочитать. 
но для ее разработки потребовались большие усилия. Статья, описывающая ее, стоит того, чтобы ее прочитать. 

Несколько замечаний. Парсер представляет собой функцию, которая принимает строку и возвращает список из некоторого
значения и новой строки. Но это есть описание \cl{state-m} монады, где состоянием является строка. Исключением является то, 
что парсер может вернуть \cl{nil} в том случае, если строка не удовлетворяет парсеру. Поэтому для реализации такой монады потребуется
что-то похожее на \cl{state-m}, но позволяющее использовать \cl{nil} в качестве монадического значения. 

Для определения монады в библиотеке \cl{clojure.contrib.monads} предусмотрена конструкция \cl{'defmonad'}. 
Таким образом, реализация монады парсера может выглядеть следующим образом:

\begin{verbatim}
(defmonad parser-m
          [m-result (fn [x]
                        (fn [strn]
                            (list x strn)))

           m-bind (fn [parser func]
                      (fn [strn]
                          (let [result (parser strn)]
                               (when (not= nil result)
                               ((func (first result)) (second result))))))

           m-zero (fn [strn]
                      nil)

           m-plus (fn [& parsers]
                      (fn [strn]
                          (first
                                (drop-while nil?
                                            (map #(% strn) parsers)))))])
\end{verbatim}


Функция \cl{m-result} точно такая же как и функция \cl{m-result} в монаде \cl{state-m}. 

Функция \cl{m-bind} немного модифицирована. Возвращаемая функция принимает
строку и применяет парсер к ней также как и в монаде \cl{state-m}. Однако, затем идет проверка: 
является ли результат \cl{nil}-ом или нет. Если да, то возвращается \cl{nil}. Если нет, то он разбивается на
части и обрабатывается также как и в монаде \cl{state-m}. 

Монада \cl{state-m} не имеет функции \cl{m-zero}. Значением <<отсутствие>>, которое сигнализирует об ошибке, 
является \cl{nil}, поэтому монадическим значением \cl{m-zero} является функция, которая лишь принимает строку и
возвращает \cl{nil}.

Функция \cl{m-plus} потребует некоторых размышлений. В общем случае в монадах \cl{m-plus} используется для 
объединения монадических значений. В монаде \cl{parser-m} монадическими значениями являются функции. 
Чтобы объединить функции, можно вызвать их одну за другой, передавая результат одной функции как
параметр другой, возможно, вставляя некоторый дополнительный код между ними. Также можно вызвать их всех
с одинаковым набором параметров и затем либо отобрать один из результатов, либо собрать все результаты
в единственное значение. 

Реализация разбора методом рекурсивного спуска потребует от нас разобрать строку с помощью
парсера, и в том случае если этот процесс завершится неудачей, необходимо будет попробовать следующий
парсер, и так до тех пор пока один из парсеров не завершится удачно. Эта задача как раз подходит
для \cl{m-plus}. \cl{m-plus} принимает в качестве параметра список парсеров и возвращает функцию, которая
принимает строку. Эта функция применяет один за другим парсер к строке, возвращая список результатов,
полученных от работы парсеров. Все что остается, это найти первый не-\cl{nil} результат и вернуть его 
в качестве результата работы функции. Дополнительным преимуществом является то, что \cl{first}, \cl{drop-while} и \cl{map} 
являются ленивыми, поэтому \cl{m-plus} применяет только то количество парсеров, которое требуется для того чтобы
получить результат. Если ни один из парсеров не завершится удачно, то возвращается \cl{nil}. 

Теперь, когда монада реализована, давайте вернемся к самим парсерам, которых у нас уже два: \cl{m-result} и \cl{m-zero},
но они слишком просты и неинтересны. 

Рассмотрим самый простой парсер, который будет распознавать первый 
символ строки, а если строка пуста, то возвращать \cl{nil}:

\begin{verbatim}
(defn any-char [strn]
      (if (= "" strn)
          nil
          (list (first strn) (. strn (substring 1)))))
\end{verbatim}

Вспомним, что когда парсер возвращает \cl{nil}, то весь процесс разбора останавливается, поэтому этот парсер
может использоваться для прекращения разбора в том случае, если строка пуста. 
%Он также распознает любой символ. 
Когда символ распознан, парсер должен вернуть значение, представленное распознанным символом, и новую
строку, полученную из старой путем удаления первого символа. 

Рассмотрим немного более сложный парсер, который принимает строку, проверяет первый символ этой строки 
и, если проверка завершилась неудачей, возвращает \cl{nil}, в противном случае --- распознанный символ и 
новую строку. 

\begin{verbatim}
(defn char-test [pred]
      (domonad parser-m
               [c any-char
                :when (pred c)]
               (str c)))
\end{verbatim}

Первое, что стоит отметить: функция \cl{'char-test'} не является парсером. Она создает парсер, используя
для этого конструкцию \cl{domonad}. Параметр \cl{'pred'}, который передается в \cl{char-test}, представляет собой 
функцию, проверяющую первый символ и возвращающую \cl{true} или \cl{false} в зависимости от того, прошла проверка 
успешно или нет. Принимая во внимание эти замечания, давайте внимательнее взглянем на конструкцию \cl{domonad} в этой функции.

В первом выражении \cl{any-char} должна обработать строку и связать результат с \cl{'c'}. Если \cl{any-char} вернет \cl{nil}, что
означает пустую строку, то парсер также вернет \cl{nil}. 

Теперь разберемся, что делает здесь \cl{:when}? Это специальное выражение, называемое охраной, или охранным выражением,
разрешающее дальнейшее вычисление в том случае, если результатом его выполнения является \cl{true}. Поэтому когда 
встречается \cl{:when}, то вызывается \cl{'pred'} со значением \cl{'c'}. Если \cl{'pred'} вернет \cl{false}, то парсер завершает 
работу и возвращает \cl{nil}. В противном случае парсер возвращает то, что определено в заключительном
выражении конструкции \cl{domonad}. В нашем случае \cl{char-test} возвращает разобранный символ как строку. 

Важный вывод, который стоит здесь сделать, заключается в том, что работа функций, обрабатывающих строку,
скрыта и не касается нас. Код был написан, отлажен и забыт. 

Итак, как определить парсер, который проверяет конкретный символ?

\begin{verbatim}
(defn is-char [c]
      (char-test (partial = c)))
\end{verbatim}

%[Почему-то это не кажется проще.] 
% По-моему, нет ничего проще.
Нет ничего проще.
Функция \cl{is-char} принимает на вход символ, а затем используется \cl{partial} для создания
другой функции, которая проверяет этот символ на равенство с первым символом входящей строки. \cl{is-char} передается 
в качестве предиката функции \cl{char-test}, которая строит парсер. Этот парсер принимает на вход строку и, 
если первый символ этой строки сопадает с переданным в \cl{is-char} символом, то возвращает список из двух строк: 
строка из первого символа и оставшаяся часть входной строки. Если первый символ не совпадает, то возвращается
\cl{nil}.

\begin{verbatim}
(def is-n (is-char \n))

(assert (= '("n" "bc")
           (is-n "nbc")))

(assert (empty?
           (is-n "xbc")))
\end{verbatim}

Очевидно, что следующим парсером, который необходимо написать, должен быть парсер, проверяющий
один за другим последовательность символов: 
%Следующий код воспринимайте с осторожностью, так как он может взорвать ваш мозг.

\begin{verbatim}
(defn match-string [target-strn]
      (if (= "" target-strn)
          (m-result "")
          (domonad parser-m
                   [c (is-char (first target-strn))
                    cs (match-string (. target-strn (substring 1)))]
                   (str c cs))))
\end{verbatim}

%Воспоминание о некоторых вещах из предыдущего текста статьи позволит сохранить правильную 
%направленность мыслей.
Давайте вспомним: 
во-первых, \cl{match-string} является функцией, которая возвращает парсер, 
а парсеры представляют собой монадические значения для монады \cl{parser-m}. 
Во-вторых, \cl{m-result} и \cl{is-char} являются функциями, которые также возвращают парсеры. 
В-третьих, в конструкции \cl{domonad} в парах <<имя выражения/выражение>> выражения должны возвращать
монадические значения (парсеры), а переменные связываться с результатом выполнения этих парсеров. 

Поэтому  \cl{match-string} проверяет является ли входящая строка пустой. Если это так, то
просто возвращается парсер, который всегда возвращает пустую строку. Этот случай является
базисом рекурсии.

Если входящая строка не пуста, то вызовом \cl{domonad} создается новый парсер. Отсюда начинается весьма 
интересная часть кода. Первое выражение обычно и является вызовом \cl{is-char}, который возвращает
парсер, разбирающий первый символ входящей строки. После успешной работы \cl{is-char} парсера
\cl{'c'} связывается с разобранным значением этого символа. Второе выражение \cl{domonad} выполняет рекурсивный вызов
\cl{match-string}, создавая парсер, который разбирает остаток строки. Этот парсер выполнится только тогда,
когда первый символ строки разобран успешно: в этом случае первый символ удаляется, а оставшаяся
строка передается для дальнейшего разбора парсеру \cl{match-string}. Если его работа завершится успешно, то 
возвращенное им значение будет ассоциировано с \cl{'cs'}. Если какая-то часть строки остается не разобранной, то
она становится частью результата вместе с заключительным выражением \cl{domonad}, которое создает единую 
строку из \cl{'c'} и \cl{'cs'}. 


\subsection{Парсер-комбинаторы}\label{parser-combinators}
Парсеры, которые мы до сих пор рассматривали, являются базисными блоками для построение
синтаксического анализатора методом рекурсивного спуска. Сейчас нам необходимо
из них построить более сложные парсеры, способные разбирать произвольные грамматики. 
Для этого нам нужен некоторый набор парсер-комбинаторов, основная идея которых 
заключается в том, чтобы получить парсер или несколько парсеров, затем модифицировать или объединить 
их для создания нового парсера, который затем может также участвовать в композиции простым блоком 
и т.д., т.д.

Рассмотрим парсер-комбинатор, полученный путем преобразования из парсера, который ОБЯЗАН обнаружить
совпадение строки, в парсер, который МОЖЕТ и обнаружить заданную строку, а может и нет. 

\begin{verbatim}
(defn optional [parser]
      (m-plus parser (m-result nil)))
\end{verbatim}

Данный парсер полезен для случая, когда мы хотим сделать что-то необязательным. Для этого нам необходимо
найти способ создания нового парсера, который завершается успешно, когда работа первого парсера
заканчивается неудачей. Новый парсер должен вернуть значение, позволяющее дальнейший разбор с того же
места, не влияя на первоначальную строку. Эта задача легко решается с помощью \cl{m-result}. Он объединяется
с первым парсером, используя \cl{m-plus}, так, что вначале первый парсер пытается разобрать
строку, и если эта попытка заканчивается неудачей, то выполняется парсер \cl{m-result}, который возвращает
список, состоящий из \cl{nil} и первоначальной строки. 

Следующий комбинатор принимает список парсеров и возвращает результат первого парсера, который
завершился успешно. Данное описание соответствует деятельности \cl{m-plus}, поэтому для создания этого
парсера достаточно переименовать \cl{m-plus}:

\begin{verbatim}
(def match-one m-plus)
\end{verbatim}

Также нам необходим комбинатор, который принимает набор парсеров, выполняет их один за другим
и возвращает конечный результат. Конструкция \cl{domonad} делает что-то похожее, но в случае с \cl{domonad}
мы должны заранее знать количество парсеров. А нам необходим комбинатор, работающий с неизвестным
набором парсеров. 

\begin{verbatim}
(defn match-all [& parsers]
      (let [combined-parsers (m-seq parsers)]
           (fn [strn]
               (let [result (combined-parsers strn)]
                    (when result
                          (list (apply str (first result))
                                (second result)))))))
\end{verbatim}

Функция \cl{m-seq} является стандартной монадной функцией, доступной всем монадам. Она принимает 
список монадических значений и последовательно выполняет их композицию, возвращая монадическое
значение (в нашем случае парсер). Проблема с \cl{m-seq} заключается в том, что этот парсер возвращает
не список, состоящий из разобранной строки и оставшейся части строки, а список, состоящий 
из списка строк и оставшейся строки. Поэтому нам необходимо собрать список из строк в одну строку,
а затем вернуть список из нашей собранной строки и оставшейся строки. 

Эту реализацию \cl{match-all} прислал мне Konrad Hinsen. Первое, что хочется отметить, \cl{combined-parsers} 
представляет собой монадическое значение. Второе --- если вынести вызов \cl{'apply str'}, то функция, 
возвращаемая \cl{match-all}, выглядит идентично функции, возвращаемой \cl{m-bind} для монады \cl{parser-m}. 

Вспомним, что монадическим значением для монады \cl{parser-m} является функция, принимающая строку
для разбора и возвращающая список из некоторого значения и оставшейся части строки. А монадическая
функция монады \cl{parser-m} принимает некоторое значение и возвращает монадическое значение. В нашем
случае нам необходима функция, которая принимает список строк и собирает их в одну, а затем
возвращает функцию, которая принимает состояние и возвращает список из объединенной строки 
и неизменного состояния. Последняя часть предыдущего предложения выполняется следующим кодом:

\begin{verbatim}
(m-result (apply str x))
\end{verbatim}
, где \cl{'x'} является списком строк, который объединяется и затем возвращается вместе с неизмененным состоянием. 
Поэтому, функция, написанная следующим образом

\begin{verbatim}
(fn [x]
    (m-result (apply str x)))
\end{verbatim}
, может быть монадической функцией для \cl{parser-m}, а также являться монадическим значением, т.е. парсером,
возвращающим список строк, которые необходимо затем объединить, что является задачей, решаемой с помощью 
\cl{combined-parsers}. Поэтому, \cl{match-all} может быть переписана следующим образом:

\begin{verbatim}
(defn match-all [& parsers]
               (m-bind (m-seq parsers)
                       (fn [x]
                           (m-result
                               (apply str x)))))
\end{verbatim}

Это даже более лаконично, чем вариант Konrad Hinsen. Можно сравнить этот вариант кода с реализацией функции \cl{m-fmap}. 

Для полноты нашего набора парсер-комбинаторов, давайте рассмотрим способ распознавания с повторением.
Существует два варианта этого комбинатора: один из них требует по-крайней мере одного успешного завершения
работы парсера, а другой нет. Они взаимно рекурсивные: каждый может быть определен через другой. 
Определить взаимно рекурсивные функции в Clojure достаточно легко:

\begin{verbatim}
(def one-or-more)

(defn none-or-more [parser]
      (optional (one-or-more parser)))

(defn one-or-more [parser]
      (domonad
               [a parser
                as (none-or-more parser)]
               (str a as)))
\end{verbatim}

Кроме взаимной рекурсии эти комбинаторы не требуют дополнительных пояснений.

Теперь с нашим набором примитивных парсеров и парсер-комбинаторов возможно построить 
синтаксический анализатор методом рекурсивного спуска для любой грамматики. Последнее,
что мы сделаем, это взглянем на несколько удобных функций:

\begin{verbatim}
(defn one-of [target-strn]
      (let [str-chars (into #{} target-strn)]
           (char-test #(contains? str-chars %))))

(def alpha (one-of "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"))
(def whitespace (one-of " \t\n\r"))
(def digit (one-of "0123456789"))
(def hexdigit (one-of "0123456789abcdefghABCDEFGH"))
\end{verbatim}

Функция \cl{one-of} может быть реализована с помощью \cl{is-char} для каждого символа в \cl{target-strn}. 
Однако, более эффективно создать \cl{hash-set} из символов \cl{target-strn} и затем, используя 
\cl{char-test}, проверять находится ли данный символ в этом \cl{hash-set}. 

Парсеры \cl{alpha}, \cl{whitespace}, \cl{digit} и \cl{hexdigit}, как и любые другие парсеры, могут
участвовать в композиции. 

\section{Заключение}\label{coming-attraction}
В данной статье речь шла об основах монад. В следующий раз я расскажу как
написать монаду \cl{parser-m} в одну строку:

\begin{verbatim}
(def parser-m (state-t maybe-m))
\end{verbatim}

\end{document}
